### IO模型有哪5种？  
![image](https://i.loli.net/2019/03/28/5c9c8fa28dff8.png)
### IO
![image](https://i.loli.net/2019/03/28/5c9c909ba570b.png)
>       IO (Input/Output，输入/输出)即数据的读取（接收）或写入（发送）操作，通常用户进程中的一个完整IO分为两阶段：用户进程空间<-->内核空间、内核空间<-->设备空间（磁盘、网络等）。IO有内存IO、网络IO和磁盘IO三种，通常我们说的IO指的是后两者。

> LINUX中进程无法直接操作I/O设备，其必须通过系统调用请求kernel来协助完成I/O动作；内核会为每个I/O设备维护一个缓冲区。  

> 对于一个输入操作来说，进程IO系统调用后，内核会先看缓冲区中有没有相应的缓存数据，没有的话再到设备中读取，因为设备IO一般速度较慢，需要等待；内核缓冲区有数据则直接复制到进程空间。  

>  所以，对于一个网络输入操作通常包括两个不同阶段：  
（1）等待网络数据到达网卡→读取到内核缓冲区，数据准备好；  
（2）从内核缓冲区复制数据到进程空间。

### 阻塞式IO
用户线程发起IO请求后，内核会去看数据是否就绪，如果没有就绪就会等待数据就绪，这时用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才能解除block状态。  
**典型应用**：阻塞Socket，Java BIO；  
**特点**：进程阻塞挂起不消耗CPU资源，及时响应每个操作；  
实现难度低，开发应用容易；  
适用并发量小的网络应用开发；  
**缺点**：不适用并发量大的应用，因为一个请求IO会阻塞进程，所以得为每一个请求分配一个线程以及时响应，系统开销大
### 非阻塞IO  
当用户线程发起一个IO操作后，并不需要等待，而是会立即得到一个结果，如果结果是error，这就表明数据还没有准备好，于是它可以再次发送IO请求。一旦内核缓冲区的数据准备好了，并且再次收到了IO请求，便会立即将数据拷贝到用户线程，然后返回。  
在非阻塞IO中，用户线程会不断的发送请求询问内核数据是否准备好，这样就会导致一直占用CPU，导致CPU占用率非常高。 
```
while(true){
    data=socket.read();
    if(data!=error){
        //处理数据
        break;
    }
}
```
**典型应用**：socket是非阻塞式的(设置为non-blocking)  
**特点**：
    用户线程不阻塞，持续占用CPU,消耗CPU资源  
    适用并发量小，且不需要及时响应的  
### IO多路复用：  
多路复用IO模型是目前使用的比较多的模型。Java NIO实际上就是多路复用IO.  
在多路复用模型中，会有一个线程不断的去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要一个线程就可以管理多个socket，系统不需要建立新的线程，也不必维护这些线程，并且只有在真正有socket读写事件进行的时候，才会使用IO资源，大大减少了资源的占用。  
**特点**：  
专一进程解决多个进程IO的阻塞问题，性能好；Reactor模式；  
适用高并发应用程序；一个进程响应多个请求。  
> Linux中IO复用的实现方式主要有select、poll和epoll：  
Select：注册IO、阻塞扫描，监听的IO最大连接数不能多于FD_SIZE；  
Poll：原理和Select相似，没有数量限制，但IO数量大扫描线性性能下降；  
Epoll ：事件驱动不阻塞，mmap实现内核与用户空间的消息传递，数量很大，Linux2.6后内核支持；

### 信号驱动IO模型  
用户线程发起一个IO操作，会给对应的socket注册一个信号函数，用户线程不阻塞，继续执行，让内核数据准备就绪会发送一个信号给用户线程，用户线程收到信号之后，便在信号函数中调用IO读写操作进行实际的IO操作。  
### 异步IO  
用户线程发起read操作之后，立刻就可以去干其他的事情了。另一方面，从内核的角度，当他收到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起，因此不会对用户线程产生任何的block,内核会等待数据准备完成，然后将数据拷贝到用户线程中，一切完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了,此时可以直接使用数据了。  
**典型应用**：Java7中的AIO


